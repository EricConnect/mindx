# 记忆系统向量索引优化方案

**创建日期**: 2026-02-23  
**作者**: GLM-5  
**状态**: 方案设计阶段

---

## 一、现状分析

### 1.1 当前实现架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                      当前记忆系统架构                                 │
│                                                                      │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐ │
│  │   Memory        │    │   BadgerStore   │    │   Embedding     │ │
│  │   (业务层)      │───▶│   (存储层)      │◀───│   Service       │ │
│  └─────────────────┘    └────────┬────────┘    └─────────────────┘ │
│                                  │                                   │
│                                  ▼                                   │
│                         ┌─────────────────┐                         │
│                         │   Badger DB     │                         │
│                         │   (KV 存储)     │                         │
│                         └─────────────────┘                         │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 核心问题

**当前搜索实现** (`badger_store.go`):

```go
func (s *BadgerStore) SearchWithThreshold(queryVec []float64, topN int, minScore float64) ([]entity.VectorEntry, error) {
    // 问题1: 全量扫描所有数据 - O(n)
    // 问题2: 每条记录都需要 JSON 反序列化
    // 问题3: 暴力计算所有向量的相似度 - O(n × d)
    // 问题4: 全量排序 - O(n log n)
}
```

### 1.3 性能问题清单

| 问题 | 影响 | 复杂度 | 严重程度 |
|------|------|--------|----------|
| **全量扫描** | 遍历所有向量数据 | O(n) | 高 |
| **JSON 反序列化** | 每次搜索重复反序列化开销 | O(n) | 高 |
| **暴力相似度计算** | 计算所有向量对的相似度 | O(n × d) | 高 |
| **无索引结构** | 无法利用空间局部性 | - | 高 |

**性能估算**:

| 数据规模 | 向量维度 | 搜索耗时（估算） |
|----------|----------|------------------|
| 1,000 条 | 768 | ~50ms |
| 10,000 条 | 768 | ~500ms |
| 100,000 条 | 768 | ~5s |
| 1,000,000 条 | 768 | ~50s |

---

## 二、优化方案：HNSW

### 2.1 方案对比

| 方案 | 查询复杂度 | 构建复杂度 | 召回率 | 内存占用 | 适用场景 |
|------|------------|------------|--------|----------|----------|
| **暴力搜索（当前）** | O(n) | - | 100% | 低 | 小数据量 |
| **HNSW** | O(log n) | O(n log n) | 95%+ | 中 | 通用场景 |
| **IVF** | O(n/k) | O(n) | 90%+ | 低 | 大数据量 |
| **LSH** | O(1) | O(n) | 80%+ | 低 | 近似搜索 |

### 2.2 HNSW 算法原理

HNSW (Hierarchical Navigable Small World) 是一种基于图的近似最近邻搜索算法。

**核心思想**:
- 构建多层图结构，上层稀疏，下层稠密
- 搜索从顶层开始，逐层向下细化
- 类似跳表的思想，实现快速定位

```
                    ┌─────────────────────────────────────┐
                    │           Layer 2 (最稀疏)           │
                    │              ●                      │
                    │             /│\                     │
                    └─────────────┬─┴─┬───────────────────┘
                                  │   │
                    ┌─────────────┼───┼───────────────────┐
                    │           Layer 1                   │
                    │         ●───●───●                   │
                    │        /│   │   │\                  │
                    └─────────┴────┴───┴─────────────────┘
                                  │
                    ┌─────────────┼───────────────────────┐
                    │           Layer 0 (最稠密)           │
                    │    ●───●───●───●───●───●            │
                    └─────────────────────────────────────┘
```

### 2.3 关键参数

| 参数 | 说明 | 推荐值 | 影响 |
|------|------|--------|------|
| `M` | 每层最大连接数 | 16 | 值越大，召回率越高，内存越大 |
| `efConstruction` | 构建时搜索宽度 | 200 | 值越大，索引质量越高，构建越慢 |
| `efSearch` | 搜索时搜索宽度 | 50 | 值越大，召回率越高，搜索越慢 |

---

## 三、架构设计

### 3.1 新架构概览

```
┌─────────────────────────────────────────────────────────────────────┐
│                      优化后记忆系统架构                               │
│                                                                      │
│  ┌─────────────────┐    ┌─────────────────────────────────────────┐│
│  │   Memory        │    │           VectorIndexManager            ││
│  │   (业务层)      │───▶│  ┌─────────────┐  ┌─────────────────┐   ││
│  └─────────────────┘    │  │   HNSW      │  │   BadgerStore   │   ││
│                         │  │   Index     │  │   (持久化)      │   ││
│                         │  │   (内存)    │  │                 │   ││
│                         │  └─────────────┘  └─────────────────┘   ││
│                         └─────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 核心接口设计

```go
package index

type VectorIndex interface {
    Insert(key string, vector []float64, metadata map[string]interface{}) error
    BatchInsert(entries []IndexEntry) error
    Search(query []float64, k int) ([]SearchResult, error)
    Delete(key string) error
    Size() int
    Save(path string) error
    Load(path string) error
}

type IndexConfig struct {
    Dimension       int     // 向量维度
    M               int     // HNSW M 参数
    EfConstruction  int     // 构建时搜索宽度
    EfSearch        int     // 搜索时搜索宽度
    DistanceMetric  string  // 距离度量：cosine, euclidean, dot
}
```

### 3.3 HNSW 索引实现

```go
package index

type HNSWIndex struct {
    index      *hnsw.HNSW
    metadata   map[string]map[string]interface{}
    config     IndexConfig
    mu         sync.RWMutex
}

func NewHNSWIndex(config IndexConfig) (*HNSWIndex, error) {
    index := hnsw.New(config.M, config.EfConstruction, hnsw.CosineDistance)
    
    return &HNSWIndex{
        index:    index,
        metadata: make(map[string]map[string]interface{}),
        config:   config,
    }, nil
}

func (h *HNSWIndex) Search(query []float64, k int) ([]SearchResult, error) {
    h.mu.RLock()
    defer h.mu.RUnlock()

    h.index.SetEf(h.config.EfSearch)
    ids, distances := h.index.Search(query, k)

    results := make([]SearchResult, 0, len(ids))
    for i, id := range ids {
        key := reverseHash(uint64(id))
        score := 1.0 - distances[i]
        
        results = append(results, SearchResult{
            Key:      key,
            Score:    score,
            Metadata: h.metadata[key],
        })
    }

    return results, nil
}
```

---

## 四、性能对比

### 4.1 预期性能提升

| 数据规模 | 向量维度 | 暴力搜索 | HNSW | 提升倍数 |
|----------|----------|----------|------|----------|
| 1,000 | 768 | 50ms | 0.5ms | 100x |
| 10,000 | 768 | 500ms | 1ms | 500x |
| 100,000 | 768 | 5s | 5ms | 1000x |
| 1,000,000 | 768 | 50s | 10ms | 5000x |

### 4.2 召回率保证

| EfSearch | 召回率 | 搜索时间 |
|----------|--------|----------|
| 20 | 90% | 最快 |
| 50 | 95% | 平衡 |
| 100 | 98% | 较慢 |
| 200 | 99% | 最慢 |

---

## 五、配置扩展

### 5.1 配置结构

```go
type VectorStoreConfig struct {
    Type            string `mapstructure:"type" yaml:"type"`
    DataPath        string `mapstructure:"data_path" yaml:"data_path"`
    Dimension       int    `mapstructure:"dimension" yaml:"dimension"`
    HNSW_M          int    `mapstructure:"hnsw_m" yaml:"hnsw_m"`
    HNSW_EfConstruction int `mapstructure:"hnsw_ef_construction" yaml:"hnsw_ef_construction"`
    HNSW_EfSearch   int    `mapstructure:"hnsw_ef_search" yaml:"hnsw_ef_search"`
}
```

### 5.2 YAML 配置示例

```yaml
vector_store:
  type: badger
  data_path: data/memory
  dimension: 768
  hnsw_m: 16
  hnsw_ef_construction: 200
  hnsw_ef_search: 50
```

---

## 六、迁移方案

### 6.1 迁移策略

```
阶段一: 双写模式
┌─────────────────────────────────────────────────────────────┐
│  Memory.Record()                                             │
│       ├──▶ BadgerStore.Put()     (旧实现)                    │
│       └──▶ HNSWIndex.Insert()    (新实现)                    │
│                                                               │
│  Memory.Search()                                              │
│       └──▶ BadgerStore.Search()  (旧实现，对比验证)           │
└─────────────────────────────────────────────────────────────┘

阶段二: 索引优先
┌─────────────────────────────────────────────────────────────┐
│  Memory.Search()                                              │
│       └──▶ HNSWIndex.Search()    (新实现)                    │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 数据迁移脚本

```go
func (m *MemoryMigrator) Migrate() error {
    entries, _ := m.oldStore.GetAll()
    
    batch := make([]index.IndexEntry, 0, 1000)
    for _, entry := range entries {
        batch = append(batch, index.IndexEntry{
            Key:      entry.Key,
            Vector:   entry.Vector,
            Metadata: parseMetadata(entry.Metadata),
        })
        
        if len(batch) >= 1000 {
            m.newIndex.BatchInsert(batch)
            batch = batch[:0]
        }
    }
    
    return nil
}
```

---

## 七、实施计划

### 7.1 阶段一：基础框架（1 周）

- [ ] 创建 `internal/index/types.go` - 定义索引接口
- [ ] 创建 `internal/index/hnsw.go` - HNSW 实现
- [ ] 创建 `internal/index/manager.go` - 索引管理器
- [ ] 编写单元测试

### 7.2 阶段二：集成测试（1 周）

- [ ] 实现 `MemoryV2`
- [ ] 编写集成测试
- [ ] 性能基准测试
- [ ] 召回率测试

### 7.3 阶段三：迁移上线（1 周）

- [ ] 实现双写模式
- [ ] 数据迁移脚本
- [ ] 灰度发布
- [ ] 监控指标

---

## 八、风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 召回率下降 | 高 | 低 | 调整 EfSearch 参数，保持 95%+ 召回率 |
| 内存占用增加 | 中 | 中 | 监控内存使用，提供参数调优 |
| 索引损坏 | 高 | 低 | 定期持久化，支持从存储重建 |
| 迁移失败 | 中 | 低 | 提供回滚方案，保留旧实现 |

---

**文档版本**: 1.0  
**最后更新**: 2026-02-23
