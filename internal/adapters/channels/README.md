# Channels 模块

## 概述

Channels 模块是一个多渠道通信适配器层，负责统一管理和处理来自不同通信渠道的消息交互。该模块提供了标准化的接口，使应用能够同时支持多种即时通讯平台、WebSocket 实时通信、Webhook 回调等多种通信方式。

## 作用

- **统一接入**：为不同的通信渠道提供统一的抽象接口，简化上层业务逻辑
- **消息路由**：智能路由消息到正确的处理流程
- **渠道切换**：支持会话级别的渠道动态切换
- **消息转发**：支持在不同渠道之间转发消息
- **生命周期管理**：统一管理各渠道的启动、停止和状态监控
- **信息同步**：自动同步所有渠道的消息到实时通道，确保信息完整性

## 特点

### 1. 统一抽象接口
所有渠道实现相同的 `Channel` 接口，包括名称、类型、描述、启动/停止、消息收发、状态查询等标准方法，确保使用一致性。

### 2. 配置驱动初始化
通过 `ChannelRegistry` 工厂模式注册表和配置文件，可以灵活地启用或禁用不同渠道，无需修改代码即可调整渠道组合。

### 3. 语义化渠道匹配
集成 Embedding 服务，支持通过语义相似度自动匹配目标渠道，实现智能的消息转发和渠道切换。

### 4. 会话上下文管理
每个会话维护独立的渠道上下文，记录当前使用的渠道，支持会话级别的渠道状态追踪。

### 5. 实时信息同步
所有渠道的消息会自动同步到 RealTimeChannel，确保 Web UI 和 Terminal UI 能够看到完整的对话历史。

### 6. 优雅关闭机制
支持等待活跃消息处理完成后再关闭，避免消息丢失，确保系统稳定性。

### 7. 完整的可观测性
包含详细的日志记录、对话日志、健康检查和状态监控，便于问题排查和系统运维。

### 8. 高并发安全
所有核心组件都采用线程安全设计，使用读写锁保护共享资源，支持高并发场景。

## 架构

### 核心组件

#### 1. Channel 接口
定义在 `core.Channel` 中，是所有渠道必须实现的标准契约，包含以下核心方法：
- `Name()`: 返回渠道唯一标识
- `Type()`: 返回渠道类型
- `Description()`: 返回渠道描述
- `Start()`: 启动渠道
- `Stop()`: 停止渠道
- `IsRunning()`: 查询运行状态
- `SetOnMessage()`: 设置消息接收回调
- `SendMessage()`: 发送消息
- `GetStatus()`: 获取详细状态

#### 2. Gateway（网关）
整个模块的核心协调者，职责包括：
- 消息路由和分发
- 处理渠道切换逻辑
- 消息转发管理
- 同步消息到 RealTimeChannel
- 优雅关闭协调
- 活跃消息计数

#### 3. ChannelManager（渠道管理器）
负责渠道的生命周期管理：
- 渠道的注册和查询
- 批量启动/停止渠道
- 配置驱动的渠道创建
- 渠道状态查询

#### 4. ChannelRegistry（渠道注册中心）
工厂模式实现，支持配置驱动的渠道初始化：
- 管理所有渠道工厂函数
- 提供渠道工厂的注册和查询
- 支持通过配置动态创建渠道实例

#### 5. ChannelContextManager（渠道上下文管理器）
管理会话级别的渠道状态：
- 记录每个会话当前使用的渠道
- 支持渠道切换记录
- 会话生命周期管理

### 支持的渠道类型

- **RealTimeChannel**: 基于 WebSocket 的实时通信，支持 Web UI 和 Terminal UI
- **WeChat**: 微信渠道
- **DingTalk**: 钉钉渠道
- **Feishu**: 飞书渠道
- **QQ**: QQ 渠道
- **Telegram**: Telegram 渠道
- **WhatsApp**: WhatsApp 渠道
- **Facebook**: Facebook 渠道
- **iMessage**: iMessage 渠道
- **WebhookChannel**: Webhook 回调渠道
- **MockChannel**: 测试用模拟渠道

## 工作原理

### 1. 初始化流程
1. 各渠道在包初始化时通过 `Register()` 函数将工厂函数注册到 `ChannelRegistry`
2. `ChannelManager` 读取配置文件，识别启用的渠道
3. 从注册表获取对应工厂函数，创建渠道实例
4. 设置消息回调，启动渠道

### 2. 消息处理流程
1. 渠道接收到用户消息，触发 `onMessage` 回调
2. `Gateway.HandleMessage()` 接收消息并开始处理
3. 确保会话上下文存在，获取当前会话的渠道
4. 同步消息到 RealTimeChannel（信息流畅性保证）
5. 调用业务逻辑处理函数 `onMessage`
6. 将响应发送回原渠道
7. 同步响应到 RealTimeChannel
8. 处理 `SendTo` 转发逻辑（如需要）
9. 通过语义匹配尝试自动切换渠道（如需要）

### 3. 渠道切换机制
- 支持通过语义相似度匹配自动切换
- 支持通过 `SendTo` 指令显式转发到其他渠道
- 切换记录保存在会话上下文中
- 切换原因会被记录到日志

### 4. 消息转发机制
- 支持将消息从一个渠道转发到另一个渠道
- 转发消息包含来源信息（渠道名、用户名）
- 转发失败时有错误提示
- 转发记录会被记录到对话日志

### 5. 优雅关闭流程
1. 标记网关为关闭状态，拒绝新消息
2. 等待所有活跃消息处理完成
3. 停止所有渠道
4. 释放资源

## 设计模式

- **工厂模式**: `ChannelRegistry` 管理渠道工厂函数
- **策略模式**: 不同渠道实现相同接口，可互换使用
- **观察者模式**: 通过 `SetOnMessage` 设置回调函数
- **单例模式**: 全局注册表实例
- **上下文模式**: 会话上下文管理

## 线程安全

所有核心组件都采用线程安全设计：
- `Gateway`: 使用 `sync.RWMutex` 保护共享状态
- `ChannelManager`: 使用 `sync.RWMutex` 保护渠道映射
- `ChannelContextManager`: 使用 `sync.RWMutex` 保护会话上下文
- 各渠道实现内部也根据需要使用适当的同步机制

## 扩展性

新增渠道只需：
1. 实现 `core.Channel` 接口
2. 在包 `init()` 函数中调用 `Register()` 注册工厂函数
3. 在配置文件中添加对应配置
4. 无需修改现有代码即可使用新渠道
